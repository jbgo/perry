module RPCMapper::Association; end

module RPCMapper::Association

  class Base
    attr_accessor :source_klass, :id, :options

    def initialize(klass, id, options={})
      self.source_klass = klass
      self.id = id.to_sym
      self.options = options
    end

    def type
      raise NotImplementedError, "You must define the type in subclasses."
    end

    def polymorphic?
      raise NotImplementedError, "You must define how your association is polymorphic in subclasses."
    end

    def collection?
      raise NotImplementedError, "You must define collection? in subclasses."
    end

    def primary_key
      options[:primary_key] || :id
    end

    def foreign_key
      options[:foreign_key]
    end

    def target_klass(object=nil)
      klass = if options[:polymorphic]
        eval [options[:polymorphic_namespace], object.send("#{id}_type")].compact.join('::') if object
      else
        raise(ArgumentError, ":class_name option required for association declaration.") unless options[:class_name]
        options[:class_name] = "::#{options[:class_name]}" unless options[:class_name] =~ /^::/
        eval(options[:class_name])
      end

      RPCMapper::Base.resolve_leaf_klass klass
    end

    def finder_options(object)
      raise NotImplementedError, "You must define finder_options in subclasses"
    end

    # Returns a scope on the target containing this association
    #
    # Uses the hash generated by the finder_options method to generate a scope on the target.
    def scope(object)
      target_klass(object).scoped.apply_finder_options finder_options(object)
    end

    # TRP: Only eager loadable if association query does not depend on instance data
    def eager_loadable?
      !(options[:sql] || RPCMapper::Relation::FINDER_OPTIONS.inject(false) { |condition, key| condition || options[key].respond_to?(:call) })
    end

    protected

    def build_finder_options(object)
      RPCMapper::Relation::FINDER_OPTIONS.inject({}) do |sum, key|
        value = self.options[key]
        sum.merge!(key => value.respond_to?(:call) ? value.call(object) : value) if value
        sum
      end
    end

  end


  class BelongsTo < Base

    def type
      :belongs_to
    end

    def collection?
      false
    end

    def foreign_key
      super || "#{id}_id".to_sym
    end

    def polymorphic?
      !!options[:polymorphic]
    end

    # Returns a hash of the finder options needed to query for this association
    #
    # belongs_to :foo, :foreign_key => :foo_id
    #
    # In addition to any finder options included with the association options the following will be added:
    #  :conditions => { :id => source[:foo_id] }
    def finder_options(object)
      base_options = build_finder_options(object)

      conditions = (object[self.foreign_key] ? { self.primary_key => object[self.foreign_key] } : nil)
      conditions = [base_options[:conditions], condition] if base_options[:conditions]

      base_options.merge({ :conditions => conditions })
    end

  end


  class Has < Base

    def foreign_key
      super || (self.polymorphic? ? "#{options[:as]}_id" : "#{RPCMapper::Base.base_class_name(source_klass).downcase}_id").to_sym
    end

    # Returns a hash of the finder options needed to query for this association
    #
    # has_many :widgets, :class_name => "Widget", :foreign_key => :widget_id
    # has_many :comments, :as => :parent
    #
    # In addition to any finder options included with the association options the following will be added:
    #  :conditions => { :widget_id => source[:id] }
    # Or for the polymorphic :comments association:
    #  :conditions => { :parent_id => source[:id], :parent_type => source.class }
    def finder_options(object)
      base_options = build_finder_options(object)

      query = if object[self.primary_key]
        conditions = { self.foreign_key => object[self.primary_key] }
        conditions.merge!(:"#{options[:as]}_type" => RPCMapper::Base.base_class_name(object.class)) if polymorphic?
        conditions
      else
        {}
      end
      query = [base_options[:conditions], query] if base_options[:conditions]

      base_options.merge(:conditions => query)
    end

    def polymorphic?
      !!options[:as]
    end

  end


  class HasMany < Has

    def collection?
      true
    end

    def type
      :has_many
    end

  end


  class HasOne < Has

    def collection?
      false
    end

    def type
      :has_one
    end

  end


end
